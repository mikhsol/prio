# Milestone 2.1: Database Migrations Strategy

**Owner**: Android Developer  
**Date**: February 4, 2026  
**Status**: ✅ Documented

---

## Overview

This document outlines the database migrations strategy for Prio MVP, covering Room database migrations and DataStore preferences versioning. Proper migration handling is critical for production apps to preserve user data during updates.

---

## Current Database Architecture

### Room Database (PrioDatabase)

**Current Version**: 1  
**Schema Location**: `core/data/schemas/com.prio.core.data.local.PrioDatabase/`

**Entities (v1)**:
| Entity | Table Name | Description |
|--------|------------|-------------|
| TaskEntity | `tasks` | Eisenhower-prioritized tasks |
| GoalEntity | `goals` | User goals with progress tracking |
| MilestoneEntity | `milestones` | Goal milestones |
| MeetingEntity | `meetings` | Calendar meetings with notes |
| DailyAnalyticsEntity | `daily_analytics` | Daily productivity metrics |

### DataStore Preferences (UserPreferencesRepository)

**File**: `prio_preferences.preferences_pb`  
**Location**: App internal storage

**Preference Keys (v1)**:
- Briefing: `morning_briefing_time`, `evening_summary_time`, `briefing_enabled`
- Theme: `theme_mode`
- Notifications: `notifications_enabled`, `reminder_advance_minutes`
- AI: `ai_model_id`, `ai_model_downloaded`, `ai_classification_enabled`, `daily_ai_limit`, `daily_ai_used`
- Onboarding: `onboarding_completed`, `first_launch_date`
- User: `user_name`
- Calendar: `calendar_connected`, `selected_calendar_ids`

---

## Migration Strategy

### Phase 1: MVP (v1.0) - Current State

For MVP launch, we use **destructive migration** as fallback:

```kotlin
Room.databaseBuilder(context, PrioDatabase::class.java, DATABASE_NAME)
    .fallbackToDestructiveMigration()
    .build()
```

**Rationale**:
- No production users yet
- Faster iteration during development
- Beta users accept data loss risk

**Limitations**:
- Must replace with proper migrations before public release
- Track schema versions carefully

### Phase 2: Beta Release (v1.0-beta) - Migration Framework

Before beta release, implement migration infrastructure:

#### 1. Create Migrations Directory
```
core/data/src/main/java/com/prio/core/data/local/migration/
├── PrioMigrations.kt          # All migrations registry
├── Migration1To2.kt           # Example migration
└── MigrationTest.kt           # Migration tests
```

#### 2. Migration Implementation Pattern
```kotlin
// Migration1To2.kt
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Example: Add new column to tasks table
        database.execSQL(
            "ALTER TABLE tasks ADD COLUMN priority_locked INTEGER NOT NULL DEFAULT 0"
        )
    }
}
```

#### 3. Register Migrations
```kotlin
// DatabaseModule.kt
Room.databaseBuilder(context, PrioDatabase::class.java, DATABASE_NAME)
    .addMigrations(
        MIGRATION_1_2,
        MIGRATION_2_3
        // ... future migrations
    )
    .fallbackToDestructiveMigration() // Keep for edge cases
    .build()
```

### Phase 3: Production (v1.1+) - Full Migration Support

After public launch, implement comprehensive migration handling:

#### 1. Automated Migration Testing
```kotlin
@RunWith(AndroidJUnit4::class)
class MigrationTest {
    @get:Rule
    val helper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        PrioDatabase::class.java
    )
    
    @Test
    fun migrate1To2() {
        // Create database at version 1
        helper.createDatabase(TEST_DB, 1).apply {
            execSQL("INSERT INTO tasks (id, title, ...) VALUES (1, 'Test', ...)")
            close()
        }
        
        // Run migration
        helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2)
        
        // Verify data preserved
        val db = helper.openDatabase(TEST_DB, 2)
        val cursor = db.query("SELECT * FROM tasks WHERE id = 1")
        assertThat(cursor.count).isEqualTo(1)
    }
}
```

#### 2. Schema Version Tracking
```kotlin
// Track in DatabaseModule or separate class
object SchemaVersions {
    const val V1_MVP = 1              // MVP launch
    const val V2_PRIORITY_LOCK = 2    // Add priority locking
    const val V3_TAGS = 3             // Add tags system
    const val CURRENT = V1_MVP
}
```

#### 3. Backup Before Migration
```kotlin
// PrioDatabase.kt companion
fun migrateWithBackup(context: Context): PrioDatabase {
    val dbFile = context.getDatabasePath(DATABASE_NAME)
    val backupFile = File(context.cacheDir, "${DATABASE_NAME}.backup")
    
    if (dbFile.exists()) {
        dbFile.copyTo(backupFile, overwrite = true)
    }
    
    return try {
        createDatabase(context)
    } catch (e: Exception) {
        Timber.e(e, "Migration failed, restoring backup")
        backupFile.copyTo(dbFile, overwrite = true)
        throw e
    }
}
```

---

## DataStore Preferences Migration

DataStore preferences are key-value based and don't require formal migrations. However, we implement **version-aware defaults** for backward compatibility:

### Strategy: Default Value Evolution

```kotlin
// UserPreferencesRepository.kt
private object PreferencesKeys {
    val PREFERENCES_VERSION = intPreferencesKey("preferences_version")
    // ... other keys
}

private const val CURRENT_PREFERENCES_VERSION = 1

suspend fun migratePreferencesIfNeeded() {
    context.dataStore.edit { prefs ->
        val version = prefs[PreferencesKeys.PREFERENCES_VERSION] ?: 0
        
        when {
            version < 1 -> migrateToV1(prefs)
            // version < 2 -> migrateToV2(prefs)
        }
        
        prefs[PreferencesKeys.PREFERENCES_VERSION] = CURRENT_PREFERENCES_VERSION
    }
}

private fun migrateToV1(prefs: MutablePreferences) {
    // Set defaults for new keys introduced in v1
    if (prefs[PreferencesKeys.REMINDER_ADVANCE_MINUTES] == null) {
        prefs[PreferencesKeys.REMINDER_ADVANCE_MINUTES] = 15
    }
}
```

### Key Deprecation Pattern

When removing a preference key:
1. Stop reading the key
2. Add migration to transfer data if needed
3. Keep key defined for 2 versions
4. Remove key definition in version N+2

```kotlin
// Example: Migrating from single time to per-day times
private fun migrateToV2(prefs: MutablePreferences) {
    // Old key: morning_briefing_time (single value)
    // New keys: monday_briefing_time, tuesday_briefing_time, etc.
    
    val oldTime = prefs[PreferencesKeys.MORNING_BRIEFING_TIME]
    if (oldTime != null) {
        // Apply old time to all days
        DayOfWeek.values().forEach { day ->
            prefs[stringPreferencesKey("${day.name.lowercase()}_briefing_time")] = oldTime
        }
    }
}
```

---

## Schema Change Guidelines

### Adding a New Column

**Safe** - Use `ALTER TABLE`:
```kotlin
database.execSQL(
    "ALTER TABLE tasks ADD COLUMN new_column TEXT DEFAULT NULL"
)
```

### Adding a New Table

**Safe** - Use `CREATE TABLE IF NOT EXISTS`:
```kotlin
database.execSQL("""
    CREATE TABLE IF NOT EXISTS new_table (
        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        ...
    )
""")
```

### Renaming a Column

**Complex** - Requires table recreation:
```kotlin
// 1. Create new table with correct schema
database.execSQL("CREATE TABLE tasks_new (...)")

// 2. Copy data
database.execSQL("""
    INSERT INTO tasks_new (id, title, new_column_name, ...)
    SELECT id, title, old_column_name, ...
    FROM tasks
""")

// 3. Drop old table
database.execSQL("DROP TABLE tasks")

// 4. Rename new table
database.execSQL("ALTER TABLE tasks_new RENAME TO tasks")

// 5. Recreate indexes
database.execSQL("CREATE INDEX ...")
```

### Changing Column Type

**Dangerous** - May lose data. Prefer:
1. Add new column with correct type
2. Copy/convert data
3. Drop old column (in next version)

### Removing a Column

**Complex** - SQLite doesn't support `DROP COLUMN` before API 35:
1. Create new table without column
2. Copy data (excluding dropped column)
3. Drop old table
4. Rename new table

---

## Testing Strategy

### Unit Tests
- Test migration SQL syntax
- Test data transformation logic
- Run in JVM with in-memory database

### Instrumented Tests
- Use `MigrationTestHelper`
- Test actual SQLite migrations
- Verify data integrity

### Manual Testing
- Test upgrade from each previous version
- Test fresh install
- Test interrupted migration (kill app during migration)

---

## Rollback Strategy

### Production Rollback

If a migration fails in production:

1. **Immediate**: App falls back to destructive migration (data loss)
2. **Planned**: 
   - Release hotfix with improved migration
   - Users can restore from cloud backup (post-MVP feature)

### Prevention

1. Always test migrations with production-like data
2. Use `fallbackToDestructiveMigrationOnDowngrade()` for debug builds
3. Monitor crash reports for migration errors
4. Implement server-side feature flags to delay schema-dependent features

---

## Version History

| Version | Release | Changes |
|---------|---------|---------|
| 1 | MVP (Feb 2026) | Initial schema: tasks, goals, milestones, meetings, daily_analytics |

---

## Action Items for Production

- [ ] Remove `fallbackToDestructiveMigration()` before public launch
- [ ] Implement migration test suite
- [ ] Add backup/restore functionality
- [ ] Set up migration monitoring in crash reporting
- [ ] Document each schema version in this file

---

*Document Owner: Android Developer*  
*Last Updated: February 4, 2026*
