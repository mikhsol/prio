# 3.1.5.B.3 — Voice Input with SpeechRecognizer

**Task**: Implement voice input with SpeechRecognizer  
**Milestone**: 3.1.5.B — Bug Fixes & Integration  
**Owner**: Android Developer  
**Status**: ✅ Completed  
**Duration**: ~3h (estimated), completed in single session  
**UX Spec**: [1.1.3 — Quick Capture Flow Spec](../1.1/1.1.3_quick_capture_flow_spec.md)  
**Date**: February 2026

---

## Summary

Implemented end-to-end voice input for the Quick Capture sheet using Android's `SpeechRecognizer` API. The implementation follows a three-layer architecture (Manager → Shell → UI), prefers on-device speech recognition for privacy, and handles all error cases with user-friendly recovery options per the UX spec.

---

## Architecture

```
┌──────────────────────────────────────────────────────────────┐
│                        PrioAppShell                          │
│  • Consumes QuickCaptureEffect.StartVoiceRecognition         │
│  • Manages RECORD_AUDIO runtime permission (Accompanist)     │
│  • Creates VoiceInputManager & collects Flow<VoiceInputState>│
│  • Pipes state updates to QuickCaptureViewModel              │
│  • Lifecycle: DisposableEffect creates/destroys manager      │
└─────────────────┬────────────────────────────────────────────┘
                  │ collects Flow<VoiceInputState>
                  ▼
┌──────────────────────────────────────────────────────────────┐
│                     VoiceInputManager                         │
│  • Wraps Android SpeechRecognizer                            │
│  • On-device preferred: createOnDeviceSpeechRecognizer (31+) │
│  • Fallback: standard SpeechRecognizer for API 29-30         │
│  • callbackFlow bridges RecognitionListener → Flow           │
│  • Maps all error codes to VoiceErrorType                    │
│  • Auto-stops: 2s speech_end + 1.5s silence_timeout          │
│  • Normalizes RMS dB → 0..1 float for waveform visualization │
└──────────────────────────────────────────────────────────────┘
                  ▲
                  │ VoiceInputState updates
                  ▼
┌──────────────────────────────────────────────────────────────┐
│              QuickCaptureSheet + VoiceInputOverlay            │
│  • VoiceInputOverlay: Composable UI overlaying capture sheet │
│  • State-driven: Initializing → Listening → Processing/Result│
│  • AudioWaveform: 20-bar sine animation driven by audioLevel │
│  • Error: [Try Again] + [Type Instead] buttons               │
│  • AnimatedVisibility enter/exit transitions                  │
└──────────────────────────────────────────────────────────────┘
```

### Data Flow (Happy Path)

1. User taps **mic icon** in Quick Capture → ViewModel emits `StartVoiceRecognition` effect
2. PrioAppShell receives effect → checks `RECORD_AUDIO` permission
3. If granted → creates `VoiceInputManager`, calls `startListening()`
4. Manager emits: `Initializing` → `Listening(partialText, audioLevel)` → `Processing(text)` → `Result(text, confidence)`
5. ViewModel receives `Result` → auto-calls `onVoiceResult(text)` → populates input field + triggers AI parsing
6. Overlay dismisses, user sees parsed task with voice-captured text

### Data Flow (Error Path)

1. SpeechRecognizer calls `onError(errorCode)`
2. Manager maps code → `VoiceErrorType` + user-friendly message
3. Overlay shows error with context-appropriate actions:
   - **NO_MATCH / NO_SPEECH / NETWORK / UNKNOWN**: Show [Try Again] + [Type Instead]
   - **NOT_AVAILABLE / PERMISSION_DENIED**: Show [Type Instead] only (no point retrying)
4. [Try Again] → ViewModel emits `StartVoiceRecognition` again (full restart)
5. [Type Instead] → Dismisses overlay, user returns to text input

---

## Files Created

| File | Package | Purpose |
|------|---------|---------|
| `VoiceInputState.kt` | `feature.capture.voice` | Sealed interface: `Idle`, `Initializing`, `Listening`, `Processing`, `Result`, `Error` + `VoiceErrorType` enum |
| `VoiceInputManager.kt` | `feature.capture.voice` | SpeechRecognizer wrapper with `callbackFlow` bridge, on-device preference, error mapping |
| `VoiceInputOverlay.kt` | `feature.capture.voice` | Compose UI: animated waveform, state-driven content, pulsing mic animation, error recovery |
| `VoiceInputStateTest.kt` | `feature.capture.voice` (test) | 13 unit tests: state properties, defaults, error types, state transitions |
| `QuickCaptureViewModelVoiceTest.kt` | `feature.capture` (test) | 9 tests: voice start, state propagation, result→parse pipeline, stop/cancel, reset |
| `VoiceInputManagerErrorMappingTest.kt` | `feature.capture.voice` (test) | 14 tests: all SpeechRecognizer error codes mapped correctly, recovery UX per spec |

## Files Modified

| File | Changes |
|------|---------|
| `QuickCaptureSheet.kt` | Added `voiceState` to `UiState`, added `RetryVoiceInput`/`CancelVoiceInput` events, integrated `VoiceInputOverlay` between input section and suggestions |
| `QuickCaptureViewModel.kt` | Added `retryVoiceInput()`, `cancelVoiceInput()`, `updateVoiceState()`, updated event handlers, auto-`onVoiceResult` on `Result` state |
| `PrioAppShell.kt` | Added Accompanist permission handling, `VoiceInputManager` lifecycle (DisposableEffect), effect consumption (LaunchedEffect), `startVoiceRecognition()` coroutine, SnackbarHost |

---

## Key Technical Decisions

### 1. On-Device vs Cloud Recognition

**Decision**: Prefer on-device, fallback to cloud

- API 31+ → `SpeechRecognizer.createOnDeviceSpeechRecognizer()` + `EXTRA_PREFER_OFFLINE`
- API 29-30 → Standard `SpeechRecognizer.createSpeechRecognizer()` with `EXTRA_PREFER_OFFLINE=true`
- **Rationale**: Aligns with Prio's privacy-first mission; on-device processing keeps voice data local. Cloud fallback ensures functionality on devices without downloaded language models.

### 2. callbackFlow for SpeechRecognizer

**Decision**: Bridge `RecognitionListener` callbacks to `Flow<VoiceInputState>` via `callbackFlow`

```kotlin
fun startListening(): Flow<VoiceInputState> = callbackFlow {
    val listener = object : RecognitionListener {
        override fun onResults(results: Bundle?) {
            trySend(VoiceInputState.Result(text, confidence))
            close()
        }
        // ...
    }
    recognizer.setRecognitionListener(listener)
    recognizer.startListening(intent)
    awaitClose { recognizer.cancel() }
}
```

- **Rationale**: Coroutine-native API integrates cleanly with ViewModel's `viewModelScope`. `awaitClose` ensures proper cleanup.

### 3. Audio Level Normalization

**Decision**: Map RMS dB (-2.0..12.0 typical range) to 0..1 float

```kotlin
// Normalize: SpeechRecognizer reports RMS dB, typically -2 to 12
val normalized = ((rmsdB + 2f) / 14f).coerceIn(0f, 1f)
```

- **Rationale**: `AudioWaveform` composable needs a 0..1 value for bar height animation. The -2..12 range was determined empirically from Android SpeechRecognizer documentation.

### 4. Permission Handling with Accompanist

**Decision**: Use Accompanist Permissions library (0.34.0) for declarative permission state in Compose

- `rememberPermissionState(Manifest.permission.RECORD_AUDIO)`
- Auto-start voice recognition after permission grant via `LaunchedEffect(status.isGranted)`
- Show snackbar with rationale if permanently denied
- **Rationale**: Cleaner than manual `ActivityResultContract` in Compose; reactive permission state integrates naturally with effect handling.

### 5. Manager Lifecycle in PrioAppShell (Not ViewModel)

**Decision**: VoiceInputManager created/destroyed in PrioAppShell's `DisposableEffect`, not in ViewModel

- **Rationale**: `SpeechRecognizer` requires a `Context` and must be used on the main thread. Keeping it in the composable layer with `DisposableEffect` cleanup prevents leaks. ViewModel stays testable with no Android dependencies.

---

## Error Mapping Reference

| SpeechRecognizer Code | VoiceErrorType | User Message | Recovery UX |
|----------------------|----------------|--------------|-------------|
| `ERROR_NO_MATCH` | `NO_MATCH` | "Couldn't understand that" | Try Again + Type Instead |
| `ERROR_SPEECH_TIMEOUT` | `NO_SPEECH` | "No speech detected" | Try Again + Type Instead |
| `ERROR_INSUFFICIENT_PERMISSIONS` | `PERMISSION_DENIED` | "Microphone permission required" | Type Instead only |
| `ERROR_NETWORK` | `NETWORK_ERROR` | "Network error. On-device recognition may not be available." | Try Again + Type Instead |
| `ERROR_NETWORK_TIMEOUT` | `NETWORK_ERROR` | "Network error. On-device recognition may not be available." | Try Again + Type Instead |
| `ERROR_SERVER` | `NETWORK_ERROR` | "Server error. Try again." | Try Again + Type Instead |
| `ERROR_RECOGNIZER_BUSY` | `UNKNOWN` | "Speech recognizer is busy, try again" | Try Again + Type Instead |
| `ERROR_CLIENT` | `UNKNOWN` | "Voice input error, please try again" | Try Again + Type Instead |
| `ERROR_AUDIO` | `UNKNOWN` | "Audio recording error" | Try Again + Type Instead |
| Unknown codes | `UNKNOWN` | "Voice input failed (error {code})" | Try Again + Type Instead |

---

## Test Coverage

### VoiceInputStateTest (13 tests)
- State property validation (text, confidence, audioLevel, errorType)
- Default values and immutability
- All 6 VoiceErrorType enum values verified
- Happy-path state transition sequence
- Error-path state transition sequence
- Unavailable device scenario

### QuickCaptureViewModelVoiceTest (9 tests)
- `startVoiceInput()` emits `StartVoiceRecognition` effect
- Voice state propagated through `UiState.voiceState`
- `Listening` state with partial text updates UI
- `Result` state auto-triggers `onVoiceResult` → parse pipeline
- `Error` state keeps voice overlay visible
- `stopVoiceInput()` and `cancelVoiceInput()` reset state
- `retryVoiceInput()` re-emits `StartVoiceRecognition`
- `reset()` clears voice state to `Idle`

### VoiceInputManagerErrorMappingTest (14 tests)
- All 9 documented SpeechRecognizer error codes mapped correctly
- Parameterized test for unknown error codes (99, 100, -1, 50)
- Error recovery UX validation: NO_MATCH allows retry, NOT_AVAILABLE/PERMISSION_DENIED do not

**Total: 36 unit tests** covering state model, ViewModel integration, and error mapping.

---

## Spec Compliance Checklist

| Requirement (from 1.1.3) | Status | Notes |
|---------------------------|--------|-------|
| Mic button opens voice capture overlay | ✅ | VoiceInputOverlay with AnimatedVisibility |
| Shows animated waveform while listening | ✅ | AudioWaveform with 20 animated bars |
| Partial results shown in real-time | ✅ | `Listening(partialText)` → displayed in overlay |
| Auto-populates text field on completion | ✅ | `Result` state → `onVoiceResult()` → input text |
| "Couldn't understand that" on no match | ✅ | `NO_MATCH` → exact spec message |
| Try Again + Type Instead buttons | ✅ | Shown for recoverable errors |
| On-device processing preferred | ✅ | `createOnDeviceSpeechRecognizer` (API 31+) |
| RECORD_AUDIO permission handling | ✅ | Accompanist + snackbar rationale |
| Stops gracefully on sheet dismiss | ✅ | `DisposableEffect` cleanup + cancel flow |

---

## Performance Considerations

- **Startup latency**: SpeechRecognizer initialization takes ~200-500ms on first use. `Initializing` state shows pulsing animation during this time.
- **Memory**: VoiceInputManager creates SpeechRecognizer only when needed, destroys on `DisposableEffect` disposal. No persistent allocation.
- **On-device model**: Requires downloaded language model. If not available, falls back to cloud (shows network errors if offline).
- **Battery**: Short sessions (< 30s typical for task capture) have negligible battery impact. Auto-stop after 2s silence prevents runaway recognition.

---

## Future Enhancements (Post-MVP)

1. **Continuous dictation**: Support longer voice input for notes/descriptions (currently optimized for short task titles)
2. **Language selection**: Let user choose recognition language beyond system default
3. **Voice commands**: "Add task buy groceries due tomorrow" with intent parsing
4. **Haptic feedback**: Vibration on recognition start/stop for tactile confirmation
5. **Offline model download prompt**: Detect missing on-device model and prompt user to download in Settings
